#pragma config(ProgramType, NonCompetition)
#pragma config(Sensor, in2,    bStay,          sensorTouch)
#pragma config(Sensor, in3,    bCent,          sensorTouch)
#pragma config(Sensor, in4,    bRght,          sensorTouch)
#pragma config(Sensor, in5,    bLeft,          sensorTouch)
#pragma config(Sensor, in6,    lOpen,          sensorTouch)
#pragma config(Sensor, in7,    lShut,          sensorTouch)
#pragma config(Sensor, in8,    lStay,          sensorTouch)
#pragma config(Motor,  port1,           eyeBall,       tmotorServoStandard, openLoop)
#pragma config(Motor,  port2,           eyeLids,       tmotorServoStandard, openLoop)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

/*************************************************************************
Animatronic Head with Moving Eyes
Sam Rice - 20210320
https://github.com/RoboticRice/LegacyVEX/

Description: This program is under development. It is intended to control
the Eye movement of an animatronic.

VEX Cortex Configuration:
*******************************
* |OOO| 1             1 |OOO| *	In this orientation:
* |OOO| 2          M  2 |OOO| *		Motors are plugged |123|
* |OOO| 3  A       O  3 |OOO| *			1: Orange
* |OOO| 4  N       T  4 |OOO| *			2: Red
* |OOO| 5  A       O  5 |OOO| *			3: Brown
* |OOO| 6  L       R  6 |OOO| *		Jumpers are connected |XOX|
* |OOO| 7  O       S  7 |OOO| *
* |OOO| 8  G          8 |OOO| *
* |OOO| 9  /                  *
* |OOO|10  D                  *
* |OOO|11  I                  *
* |OOO|12  G                  *
* |OOO|13  I       I  1 |OOO| *
* |OOO|14  T       N  2 |OOO| *
* |OOO|15  A       T  3 |OOO| *
* |OOO|16  L       R  4 |OOO| *
* |OOO|RX          P  5 |OOO| *
* |OOO|TX          S  6 |OOO| *
*                             *
*             VEX             *
*                             *
*******************************

Additional Notes:
* The "bVexAutonomousMode = false;" is needed to open up communication so
  that the VEX can talk to the radio transmitter. We aren't driving this
  model via remote, so I have set this to "true"
* Need to add Eye Lids movement at a later date.
*************************************************************************/

#define CENTER 0
#define RMAX -100
#define LMAX 100
#define OPEN 0 //guesses
#define SHUT 100 //guesses
#define INTERVAL_IN_SECONDS 2
//Define State Values
#define BALL_STAY 0 //Eye Balls remain still at current position (to be used as default or error)
#define BALL_MOVE 1 //Eye Balls move L/R and Center at defined intervals
#define BALL_CENT 2 //Eye Balls move to center (if not already there) and remain still
#define BALL_RGHT 3 //Eye Balls move to look right (if not already there) and remain still
#define BALL_LEFT 4 //Eye Balls move to look left (if not already there) and remain still
#define BALL_TRCK 5 //Experimental idea to get a position and follow the position, ie. follow guest movement
#define LIDS_STAY 0 //Eye Lids remain still at current position (to be used as default or error)
#define LIDS_OPEN 1 //Eye Lids remain still in the open position
#define LIDS_SHUT 2 //Eye Lids remain still in the closed position
#define LIDS_MOVE 3 //Eye Lids blink at defined intervals

char getStateBall();
char getStateLids();

task main()
{
	//Run Once on Init Code Block
	bVexAutonomousMode = true;//Disables Remote Control Mode

	/*PROGRAMMING NOTE: "signed char" is a variable that contains an interger value between -127 and +127*/
	signed char	posBall = 0;
	signed char	posLids = 0;
	bool increaseBall = true;
	bool increaseLids = true;
	short pauseTime = 200; //I want to make this NOT a wait function moving forward.

	char stateBall = getStateBall();
	char stateLids = getStateLids();

	while (true)//Creates and infinite loop
	{
		//Main Continuous Code Block
		switch (stateBall) {
			case BALL_MOVE :
				//DEPRECIATED - will remove later if I can't find a use for this
				if (posBall >= LMAX)
				{
					increaseBall = false; //decrease
					wait10Msec(pauseTime);
				}
				else if (posBall <= RMAX)
				{
					increaseBall = true; //increase
					wait10Msec(pauseTime);
				}
				else if (posBall == CENTER)
					wait10Msec(pauseTime);

				posBall = posBall - (1-(2*increaseBall));
				//2*increase=0 if false, 2 if true
				//1-0 = 1 ;; 1-2 = -1
				//pos - 1 = decrease ;; pos - (-1) = increase
				break;
			case BALL_CENT :
				if (posBall > CENTER)
					posBall = posBall - 1;
				else if (posBall < CENTER)
					posBall = posBall + 1;
				break;
			case BALL_LEFT :
				if (posBall < LMAX)
					posBall = posBall + 1;
				break;
			case BALL_RGHT :
				if (posBall > RMAX)
					posBall = posBall - 1;
				break;
			case BALL_TRCK :
				//no code for this yet...
			default : //BALL_STAY
			//No code required, as the value of posBall will remain unchanged, and thus the eyeBalls will stay still
		}

		switch (stateLids) {
			case LIDS_MOVE :
				//Note to self: need to remove wait statements
				if (posLids >= SHUT)
				{
					increaseLids = false; //decrease
					//wait10Msec(pauseTime);
				}
				else if (posLids <= OPEN)
				{
					increaseLids = true; //increase
					//wait10Msec(pauseTime);
				}

				posLids = posLids - (1-(2*increaseLids));
				//2*increase=0 if false, 2 if true
				//1-0 = 1 ;; 1-2 = -1
				//pos - 1 = decrease ;; pos - (-1) = increase
				break;
			case LIDS_OPEN :
				if (posLids > OPEN)
					posLids = posLids - 1;
				break;
			case LIDS_SHUT :
				if (posLids < SHUT)
					posLids = posLids + 1;
				break;
			default : //LIDS_STAY
			//No code required, as the value of posLids will remain unchanged, and thus the eyeLids will stay still
		}

		motor[eyeBall] = posBall;
		motor[eyeLids] = posLids;

		wait1Msec(2); //2ms intervals between each loop makes movement appear to be more natural

		stateBall = getStateBall();
		stateLids = getStateLids();
	}
}

char getStateBall() {
	//b[stay, move, cent, rght, left]
	if (bVexAutonomousMode) {
		if (SensorValue[bStay])
			return BALL_STAY;
		else if (SensorValue[bCent])
			return BALL_CENT;
		else if (SensorValue[bRght])
			return BALL_RGHT;
		else if (SensorValue[bLeft])
			return BALL_LEFT;
		//else if (0=1) //I do not have a method of starting this yet...
			//return BALL_TRCK;
		else {
			//return BALL_MOVE;
			if (time100[T1] < (INTERVAL_IN_SECONDS * 10)) //theory, add a rand# between -10 and +10 (100ms) each time
				return BALL_CENT;
			else if (time100[T1] < (INTERVAL_IN_SECONDS * 20))
				return BALL_LEFT;
			else if (time100[T1] < (INTERVAL_IN_SECONDS * 30))
				return BALL_RGHT;
			else if (time100[T1] < (INTERVAL_IN_SECONDS * 40))
				return BALL_CENT;
			else if (time100[T1] < (INTERVAL_IN_SECONDS * 50))
				return BALL_RGHT;
			else if (time100[T1] < (INTERVAL_IN_SECONDS * 60))
				return BALL_CENT;
			else if (time100[T1] < (INTERVAL_IN_SECONDS * 70))
				return BALL_LEFT;
			else
				ClearTimer(T1);
      return BALL_CENT;
		}
	} else {
		//Controller input, which is currently unplanned - but this is where I'd add it if I want to scare guests lol
		return BALL_STAY;
	}
}

char getStateLids() {
	//l[open, shut, move, stay]
	if (bVexAutonomousMode) {
		if (SensorValue[lStay])
			return LIDS_STAY;
		else if (SensorValue[lShut])
			return LIDS_SHUT;
		else if (SensorValue[lOpen])
			return LIDS_OPEN;
		else
			return LIDS_MOVE;
	} else {
		//Controller input, which is currently unplanned - but this is where I'd add it if I want to scare guests lol
		return LIDS_STAY;
	}
}
